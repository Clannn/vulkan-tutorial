# Vulkan Introduction

​	相对于OpenGL，vulkan为现代GPU提供更好的抽象，这些接口可以帮助你更好的描述你要做什么，以及更优秀的性能，更少的驱动调用；代价是API过于冗长。

​	OpenGL设计于固定管线的时代，随着显卡架构的成熟，开始提供越来越多的可编程功能，这些功能需要于现存的API集成，导致了不太理想的抽象，显卡驱动需要大量的猜测来揣测程序员的意图。OpenGL难以支持多线程，可能会导致CPU端出现瓶颈。

​	Vulkan使用更冗长的API明确指定程序员的意图，从而减少驱动程序的开销。并且支持多线程并行的创建和提交命令。为了解决shader编译中的不一致（不同着色器的语法不同），使用一个编译器将shader切换到标准化的字节码格式。

### Vulkan渲染的整体流程

1. 实例创建和物理设备选择

   通过创建一个实例（`VkInstance`）来配置Vulkan API，创建实例需要描述应用程序的信息以及将使用的API扩展。之后可以查询并选择一个或多个Vulkan支持的物理设备（`VkPhysicalDevices`），可以通过物理设备的属性和功能来选择合适的GPU。

2. 逻辑设备和队列族（queue families）

   为选择好的物理设备创建对应的逻辑设备，此时需要明确指定需要开启的设备功能（`VkPhysicalDeviceFeatures`），比如多视口渲染和64位浮点，还需要指定要使用的队列族。几乎所有跟GPU相关的操作，在Vulkan中都是通过将命令提交到队列（`VkQueue`）来执行的，队列是通过队列族分配而来，每个队列族支持一系列特定的操作，比如图形操作、计算操作、内存交换操作。选择物理设备时，所支持的队列族也是一个重要指标。

3. 窗口表面和交换链（swap chain）

   为了渲染一个窗口，我们需要窗口表面（`VkSurfaceKHR`）和交换链（`VkSwapchainKHR`），`KHR`后缀意味着这些对象是Vulkan扩展的一部分，表面是对窗口的一个跨平台抽象。交换链是一个图像的集合，基本目的是为了保证当前渲染的图像与屏幕上呈现的图像不同，每当我们想要渲染一帧时，需要向交换链申请一张图像来渲染，渲染完成后将图像返回给交换链，图像将在之后的某个时间点被呈现到屏幕上。交换链中图像的个数和呈现的时机取决于呈现模式，常见的模式包括垂直同步和三重缓冲。

4. 图像视图（image views）和帧缓冲

   为了渲染一张从交换链中获取的图像，我们需要将它“包裹”进一个`VkImageView`和`VkFramebuffer`，一个图像视图引用了图像的特定部分。帧缓冲引用一些图像视图，将它们作为颜色、深度和模板目标等。需要为每一个交换链中的图像创建对应的视图和帧缓冲。

5. 渲染流程（Render passes）

   渲染流程描述了在渲染操作中要使用的图像信息，比如将某张图像作为颜色目标，并且在渲染操作之前执行clear color操作。注意渲染流程中只描述图像信息，`VkFramebuffer`将真正的图像与对应的信息绑定。

6. 图形管线

   通过创建`VkPipeline`对象创建图形管线，它描述了显卡的所有可配置状态，通过`VkShaderModule`配置可编程状态，`VkShaderModule`通过标准化的shader字节码创建。管线同样需要知道哪些渲染目标将被用到，通过指定对应的渲染流程来实现这一步。

   几乎所有管线状态都需要提前配置（不能动态改变），意味着如果你想对管线做一些修改，比如改变shader，需要重新创建整条管线。因此，通常提前创建好多条渲染管线，并组合使用它们。这么做的好处是，由于整条管线的行为是可预测的，因此显卡驱动有更多的优化机会。有一小部分配置可以动态改变，比如：视口大小，clear color颜色。

7. 命令池和命令缓冲

   前面提到Vulkan中的许多操作都需要提交到队列中执行，这些操作首先会被记录到`VkCommandBuffer`对象中，命令缓冲通过命令池分配，一个命令池与特定的队列族绑定。如果只是画一个三角形，我们需要执行以下命令：

   - 开始一个渲染流程
   - 绑定图形管线
   - 绘制三个顶点
   - 结束一个渲染流程

   如果可以，可以提前为每个交换链中的图像录制好命令，这个可以提高性能，当然也可以在主循环中录制命令。

8. 主循环

   假设渲染命令已经录制命令缓冲中，首先需要从交换链中获取一张图像，然后选择对应的命令缓冲并将它提交到队列中，最后将图像返回给交换链以呈现在屏幕上。

   提交到队列中的操作是异步执行的，因此我们需要一些同步对象（如信号量）来确保正确的执行顺序。

   - 执行绘制命令之前，需要确保图像已经获取完毕
   - 返回给交换链之前，需要等待绘制命令执行结束

### 总结

​	简单来说，为了渲染一个三角形，我们需要以下步骤：

- 创建一个`VkInstance`
- 选择一个Vulkan支持的显卡（`VkPhysicalDevice`）
- 创建逻辑设备（`VkDevice`）并创建用于绘制和呈现的队列（`VkQueue`）
- 创建窗口，窗口表面和交换链
- 将交换链中的图像“包裹”进`VkImageView`
- 创建一个渲染流程用于描述需要用到的渲染目标们的信息
- 为渲染流程创建对应的帧缓冲，以绑定真正的图像
- 配置图形管线
- 为交换链中的每个image分配并记录对应的命令缓冲
- 通过获取图像、提交对应的命令缓冲、返回图像到交换链三个步骤来绘制一帧

### Vulkan API通用概念

​	所有的函数都使用`vk`作为前缀，所有的结构体或枚举类型都使用`Vk`作为前缀，枚举值使用`VK`作为前缀。许多Vulkan中的结构体都需要通过`sType`成员显式指定结构体类型，`pNext`成员可以指向一个扩展结构体。创建或销毁对象的函数都包含一个`VkAllocationCallbacks`参数，允许使用自定义的分配器管理内存。几乎所有函数都返回一个`VkResult`，要么是`VK_SUCCESS`，要么是一个错误码。